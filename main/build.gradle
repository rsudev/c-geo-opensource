/*
 * Run "gradlew" or "gradlew cgeoHelp" in the parent directory for a help of how to use this build file.
 */


/* 
 * Android plugin, http://developer.android.com/tools/building/plugin-for-gradle.html
 */
apply plugin: 'com.android.application'

android {
    compileSdkVersion "Google Inc.:Google APIs:22"
    buildToolsVersion "23.0.2"

    compileOptions {
    	// use the diamond operator and some other goodies in Android
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    defaultConfig {
        // TODO fill this section and remove the values from AndroidManifest only after the full switch to gradle
        // As these values override the manifest, we might otherwise use different values in gradle and non-gradle builds.
        minSdkVersion 9
        targetSdkVersion 21
        versionName versionNameFromDate()
        versionCode versionCodeFromDate()

        // NOTE: must match the package in the test directory and must be different from the app package
        testApplicationId "cgeo.geocaching.test"

        //testHandlingProfiling true
        testFunctionalTest true

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

        // by convention, the folder name "main" is used for the APK file name. we want cgeo instead
        archivesBaseName = "cgeo"
    }

    // signing is handled via private.properties
    signingConfigs {
        release
    }

    buildTypes {
        debug {
            // debug build name contains git commit for better reproduction of bugs
            versionNameSuffix "-" + gitCommitId().substring(0, 7) + " developer build"

            // additional proguard rules just for the test code
			testProguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-project.txt', '../tests/proguard-project.txt'
        }
        release {
            signingConfig signingConfigs.release
        }
    }
    
    buildTypes.all { buildType ->
        // enable proguard and remove unused code
        buildType.minifyEnabled true

        // remove unused resources in addition to unused code
        shrinkResources true

		// proguard rules
        buildType.proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-project.txt'
    }

    testBuildType "debug" //the default BuildType

    sourceSets {
    	// application sources in source set "main"
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src', 'thirdparty', '../common/src'] // no need for annotation generated sources
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
        }
        // device/emulator based instrumentation tests in source set "androidTest"
        androidTest{
            // map tests to the Eclipse style test project
            setRoot("../tests")
            manifest.srcFile '../tests/AndroidManifest.xml'
            java.srcDirs = ['../tests/src', 'src']
            resources.srcDirs = ['../tests/src']
            res.srcDirs = ['../tests/res']
        }
    }

    testOptions {
        resultsDir = "$project.buildDir/build/test-results"
    }

    lintOptions {
    	// generally we accept lint errors when building 
        abortOnError false
        
    	// abort release builds in case of FATAL errors
        checkReleaseBuilds true

        // recommended by ButterKnife, http://jakewharton.github.io/butterknife/
        disable 'InvalidPackage'
    }

    packagingOptions {
        // license files of libs are not needed in our APK
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/dependencies'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/notice'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/license'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/license.txt'
        exclude 'META-INF/NOTICE.txt'
        exclude 'META-INF/notice.txt'
        exclude 'COPYING'
        exclude 'COPYING.LESSER'
        exclude '.readme'
        // findbugs
        exclude 'META-INF/maven/com.google.code.findbugs/jsr305/pom.properties'
        exclude 'META-INF/maven/com.google.code.findbugs/jsr305/pom.xml'
        // httpclientandroidlib
        exclude 'ch/boye/httpclientandroidlib/impl/conn/tsccm/doc-files/tsccm-structure.png'
    }
}

/*
 * AndroidAnnotations, https://github.com/excilys/androidannotations/wiki/building-project-gradle
 */
apply plugin: 'android-apt'

apt {
    arguments {
        androidManifestFile variant.outputs[0].processResources.manifestFile
        // suppress verbose output of the AndroidAnnotations processor
        logLevel 'error'
    }
}


dependencies {
/*
 * cgeo library dependencies. add gradle plugin related dependencies further down below
 */
    // Maps.ME integration
    compile project(":mapswithme-api")

    // Showcase view
    // TODO replace by repository dependency. however, there is a conflict in min sdk, which needs to be solved then
    compile project(":showcaseview")

    compile files('libs/httpclientandroidlib-1.1.2.jar')
    compile files('libs/locus-api-4.0.jar')
    compile files('libs/mapsforge-map-0.3.0-jar-with-dependencies.jar')
    compile files('libs/androidsvg-1.2.2-beta-1.jar')
    compile files('libs/mapsforge-core-release-0.5.2.jar')
    compile files('libs/mapsforge-map-release-0.5.2.jar')
    compile files('libs/mapsforge-map-android-release-0.5.2.jar')
    compile files('libs/mapsforge-map-reader-release-0.5.2.jar')

    compile 'com.android.support:appcompat-v7:20.0.0'
    compile 'com.google.android.gms:play-services-maps:8.3.0'
    compile 'com.google.android.gms:play-services-location:8.3.0'

    // Apache Commons
    compile 'org.apache.commons:commons-collections4:4.0'
    compile 'org.apache.commons:commons-lang3:3.4'
    compile 'commons-io:commons-io:2.4'
    compile 'com.google.code.findbugs:annotations:3.0.1u2'
    androidTestCompile 'com.google.code.findbugs:annotations:3.0.1u2'

    // Reactive extensions
    compile 'io.reactivex:rxjava:1.0.16'
    compile 'io.reactivex:rxandroid:0.25.0'

    // Jackson XML processing
    compile 'com.fasterxml.jackson.core:jackson-core:2.6.3'
    compile 'com.fasterxml.jackson.core:jackson-databind:2.6.3'
    compile 'com.fasterxml.jackson.core:jackson-annotations:2.6.3'

    // Zxing barcode reader integration
    compile 'com.google.zxing:android-integration:3.2.1'

    // Null annotations
    compile 'org.eclipse.jdt:org.eclipse.jdt.annotation:1.1.0'

    // Undo toast
    compile 'com.github.jenzz.undobar:library:1.3:api8Release@aar'
    compile 'com.nineoldandroids:library:2.4.0'

    //Robotium / Robolectric??
    androidTestCompile files('../tests/libs/android-junit-report-1.5.8.jar')
    
    // AssertJ for testing
    androidTestCompile 'org.assertj:assertj-core:1.7.0'

    // Espresso
    androidTestCompile 'com.jakewharton.espresso:espresso:1.1-r3'

/*
 * AndroidAnnotations, https://github.com/excilys/androidannotations/wiki/building-project-gradle
 */
    apt( 'org.androidannotations:androidannotations:3.3.2'){
        exclude module:'androidannotations-api'
    }
    compile 'org.androidannotations:androidannotations-api:3.3.2'

/*
 * ButterKnife view injection, https://github.com/JakeWharton/butterknife
 */
    compile 'com.jakewharton:butterknife:7.0.1'
}


/*
 * verify existence of the necessary keys for compilation, instead of waiting for a compile error
 */

project.afterEvaluate{
    preBuild.dependsOn("verifyCgeoKeys")
}

task verifyCgeoKeys {
    doFirst {
        def keysFile = file("res/values/keys.xml")
        if (!keysFile.exists()) {
            throw new InvalidUserDataException("You must provide keys in main/res/values/keys.xml for cgeo to compile successfully. You can copy from main/templates/keys.xml and just add the necessary values.")
        }
    }
}

configure (verifyCgeoKeys) {
    group = 'verification'
    description = 'Checks for the existence of keys.xml to successfully compile cgeo.'
}


/*
 * version number from the current date
 */
def versionCodeFromDate() {
    def date = new Date()
    def formattedDate = date.format('yyyyMMdd')
    return Integer.valueOf(formattedDate)
}

/* 
 * version name based on current date
 */ 
def versionNameFromDate() {
    def date = new Date()
    def formattedDate = date.format('yyyy.MM.dd')
    return formattedDate
}

/*
 * get the most recent git commit ID
 */
def gitCommitId() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', 'HEAD'
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

/*
 * have a run task for our builds to launch the app directly from gradle
 */
android.applicationVariants.all { variant ->
    if (variant.install) {
        tasks.create(name: "run${variant.name.capitalize()}", dependsOn: variant.install) {
            group 'cgeo'
            description "Installs the ${variant.description} and runs the main launcher activity. Depends on 'adb' being on the PATH."

            doFirst {
                def classpath = variant.applicationId
                if (variant.buildType.applicationIdSuffix) {
                    classpath -= "${variant.buildType.applicationIdSuffix}"
                }
                def launchClass = "${variant.applicationId}/${classpath}.MainActivity"
                project.exec {
                    executable = 'adb'
                    args = ['shell', 'am', 'start', '-n', launchClass]
                }
            }
        }
    }
}

/*
 * signing of release APK, use a properties file like in templates/private.properties
 */

// dynamically load the signing values from private.properties
File privatePropertiesFile = rootProject.file('private.properties')
if (privatePropertiesFile.exists()) {
    Properties properties = new Properties()
    properties.load(new FileInputStream(privatePropertiesFile))
    android.signingConfigs {
        release {
            storeFile file(properties.getProperty('key.store'))
            storePassword properties.getProperty('key.store.password')
            keyAlias properties.getProperty('key.alias')
            keyPassword properties.getProperty('key.alias.password')
        }
    }
    android.buildTypes.release.signingConfig android.signingConfigs.release
}

// check existence of private properties, show an error message
task verifyPrivateProperties << {
    if (!rootProject.file('private.properties').exists()) {
        throw new InvalidUserDataException("For signing the release build you must provide a file private.properties in the root directory. Copy templates/private.properties and change the values.")
    }
}

// only verify the existence of private.properties, when the file is really needed
tasks.whenTaskAdded { theTask ->
    if (theTask.name.equals("packageRelease")) {
        theTask.dependsOn "verifyPrivateProperties"
    }
}
